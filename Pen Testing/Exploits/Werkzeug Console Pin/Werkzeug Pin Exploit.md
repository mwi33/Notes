# Overview
The flask application uses 'Werkzeug' as its web application framework.  This framework includes configurations that support development of web applications.  It is intended that these configurations are disabled when a web application is migrated to a production instance.
One of the tools available within the Developer configuration is a 'debug' console, which provides developers the ability to execute python commands.  By default it includes a PIN as a security measure in case this feature isn't disabled after a production migration.

## PIN
The debug console PIN is enabled by default and the PIN is generated using project specific data.  This requires that certain server and application data (variables) are concatenated and hashed to provide a pin for access.  Using 'Directory Traversal'  exploits the required variables can be obtained and then used with the required function to obtain the correct hash and PIN.
## Exploit
Within the 'Werkzeug'  source code, there is a function that accepts several arguments and creates a 'sha1' hash which is then salted and converted into a 9 digit PIN for access to the debugger.  
This exploit requires that a 'Directory Traversal' exploit is utilised to obtain the required arguments (server and app specific) and are then used in a remote version of the hash and salt function to obtain the required PIN.
The relevant source code is provided below.

```python
def get_pin_and_cookie_name(
    app: WSGIApplication,
) -> tuple[str, str] | tuple[None, None]:
    """Given an application object this returns a semi-stable 9 digit pin
    code and a random key.  The hope is that this is stable between
    restarts to not make debugging particularly frustrating.  If the pin
    was forcefully disabled this returns `None`.

    Second item in the resulting tuple is the cookie name for remembering.
    """
    pin = os.environ.get("WERKZEUG_DEBUG_PIN")
    rv = None
    num = None

    # Pin was explicitly disabled
    if pin == "off":
        return None, None

    # Pin was provided explicitly
    if pin is not None and pin.replace("-", "").isdecimal():
        # If there are separators in the pin, return it directly
        if "-" in pin:
            rv = pin
        else:
            num = pin

    modname = getattr(app, "__module__", t.cast(object, app).__class__.__module__)
    username: str | None

    try:
        # getuser imports the pwd module, which does not exist in Google
        # App Engine. It may also raise a KeyError if the UID does not
        # have a username, such as in Docker.
        username = getpass.getuser()
    except (ImportError, KeyError):
        username = None

    mod = sys.modules.get(modname)

    # This information only exists to make the cookie unique on the
    # computer, not as a security feature.
    probably_public_bits = [
        username,
        modname,
        getattr(app, "__name__", type(app).__name__),
        getattr(mod, "__file__", None),
    ]

    # This information is here to make it harder for an attacker to
    # guess the cookie name.  They are unlikely to be contained anywhere
    # within the unauthenticated debug page.
    private_bits = [str(uuid.getnode()), get_machine_id()]

    h = hashlib.sha1()
    for bit in chain(probably_public_bits, private_bits):
        if not bit:
            continue
        if isinstance(bit, str):
            bit = bit.encode()
        h.update(bit)
    h.update(b"cookiesalt")

    cookie_name = f"__wzd{h.hexdigest()[:20]}"

    # If we need to generate a pin we salt it a bit more so that we don't
    # end up with the same value and generate out 9 digits
    if num is None:
        h.update(b"pinsalt")
        num = f"{int(h.hexdigest(), 16):09d}"[:9]

    # Format the pincode in groups of digits for easier remembering if
    # we don't have a result yet.
    if rv is None:
        for group_size in 5, 4, 3:
            if len(num) % group_size == 0:
                rv = "-".join(
                    num[x : x + group_size].rjust(group_size, "0")
                    for x in range(0, len(num), group_size)
                )
                break
        else:
            rv = num

    return rv, cookie_name
```

At a high-level, the code above creates two lists (probably_public_bits and private_bits) and these two lists are provided to a function which uses both a hash function and salting to create a hash which is then used to create a 9 digit pin.
### probably_public_bits
* username;
* modname;
* getattr(app, "__name__", type(app).__name__); and
* getattr(mod, "__file__", None).*
### private_bits
*  uuid.getnode(), get_machine_id()*
